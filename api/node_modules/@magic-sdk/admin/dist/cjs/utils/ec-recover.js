"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecRecover = void 0;
const keccak_js_1 = require("ethereum-cryptography/keccak.js");
const secp256k1_compat_js_1 = require("ethereum-cryptography/secp256k1-compat.js");
const utils_js_1 = require("ethereum-cryptography/utils.js");
function hashPersonalMessage(message) {
    const prefix = (0, utils_js_1.utf8ToBytes)(`\u0019Ethereum Signed Message:\n${message.length}`);
    const totalLength = prefix.length + message.length;
    const output = new Uint8Array(totalLength);
    output.set(prefix);
    output.set(message, prefix.length);
    return (0, keccak_js_1.keccak256)(output);
}
function getRecoveryBit(signature) {
    const bit = signature[64];
    return bit - 27;
}
function prepareSignature(signature) {
    return signature.slice(2); // strip the `0x` prefix
}
function publicKeyToAddress(publicKey) {
    const address = (0, keccak_js_1.keccak256)(publicKey.slice(1)).slice(-20);
    return `0x${(0, utils_js_1.bytesToHex)(address)}`;
}
/**
 * Recover the signer from an Elliptic Curve signature.
 */
function ecRecover(data, signature) {
    // Use ecdsaRecover on the Proof, to validate if it recovers to the expected
    // Claim, and expected Signer Address.
    const msg = (0, utils_js_1.utf8ToBytes)(data);
    const sig = (0, utils_js_1.hexToBytes)(prepareSignature(signature));
    const recovery = getRecoveryBit(sig);
    const hash = hashPersonalMessage(msg);
    const publicKey = (0, secp256k1_compat_js_1.ecdsaRecover)(sig.slice(0, 64), recovery, hash, false);
    const assertPublicKey = (0, secp256k1_compat_js_1.publicKeyConvert)(publicKey, false);
    return publicKeyToAddress(assertPublicKey);
}
exports.ecRecover = ecRecover;
//# sourceMappingURL=ec-recover.js.map