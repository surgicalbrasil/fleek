"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtilsModule = void 0;
const ethers_1 = require("ethers");
const base_module_1 = require("../base-module");
const sdk_exceptions_1 = require("../../core/sdk-exceptions");
const ownershipABIs_1 = require("./ownershipABIs");
const types_1 = require("../../types");
class UtilsModule extends base_module_1.BaseModule {
    /**
     * Parse a raw DID Token from the given Authorization header.
     */
    parseAuthorizationHeader(header) {
        if (!header.toLowerCase().startsWith('bearer ')) {
            throw (0, sdk_exceptions_1.createExpectedBearerStringError)();
        }
        return header.substring(7);
    }
    // Token Gating function validates user ownership of wallet + NFT
    validateTokenOwnership(didToken, contractAddress, contractType, rpcURL, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Make sure if ERC1155 has a tokenId
            if (contractType === 'ERC1155' && !tokenId) {
                throw new Error('ERC1155 requires a tokenId');
            }
            // Validate DID token
            let walletAddress;
            try {
                yield this.sdk.token.validate(didToken);
                walletAddress = this.sdk.token.getPublicAddress(didToken);
            }
            catch (e) {
                // Check if code is malformed token
                if (e.code && e.code === 'ERROR_MALFORMED_TOKEN') {
                    return {
                        valid: false,
                        error_code: 'UNAUTHORIZED',
                        message: 'Invalid DID token: ' + types_1.ErrorCode.MalformedTokenError,
                    };
                }
                if (e.code === types_1.ErrorCode.TokenExpired) {
                    return {
                        valid: false,
                        error_code: 'UNAUTHORIZED',
                        message: 'Invalid DID token: ' + types_1.ErrorCode.TokenExpired,
                    };
                }
                throw new Error(e);
            }
            // Check on-chain if user owns NFT by calling contract with web3
            let balance = BigInt(0);
            const provider = new ethers_1.ethers.JsonRpcProvider(rpcURL);
            if (contractType === 'ERC721') {
                const contract = new ethers_1.ethers.Contract(contractAddress, ownershipABIs_1.ERC721ContractABI, provider);
                balance = BigInt(yield contract.balanceOf(walletAddress));
            }
            else {
                const contract = new ethers_1.ethers.Contract(contractAddress, ownershipABIs_1.ERC1155ContractABI, provider);
                balance = BigInt(yield contract.balanceOf(walletAddress, tokenId));
            }
            if (balance > BigInt(0)) {
                return {
                    valid: true,
                    error_code: '',
                    message: '',
                };
            }
            return {
                valid: false,
                error_code: 'NO_OWNERSHIP',
                message: 'User does not own this token.',
            };
        });
    }
}
exports.UtilsModule = UtilsModule;
//# sourceMappingURL=index.js.map