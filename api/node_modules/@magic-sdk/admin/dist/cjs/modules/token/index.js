"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenModule = void 0;
/* eslint-disable prefer-destructuring */
const base_module_1 = require("../base-module");
const sdk_exceptions_1 = require("../../core/sdk-exceptions");
const ec_recover_1 = require("../../utils/ec-recover");
const parse_didt_1 = require("../../utils/parse-didt");
const issuer_1 = require("../../utils/issuer");
class TokenModule extends base_module_1.BaseModule {
    validate(DIDToken, attachment = 'none') {
        let tokenSigner = '';
        let attachmentSigner = null;
        let claimedIssuer = '';
        let parsedClaim;
        let proof;
        let claim;
        try {
            const tokenParseResult = (0, parse_didt_1.parseDIDToken)(DIDToken);
            [proof, claim] = tokenParseResult.raw;
            parsedClaim = tokenParseResult.withParsedClaim[1];
            claimedIssuer = (0, issuer_1.parsePublicAddressFromIssuer)(parsedClaim.iss);
        }
        catch (_a) {
            throw (0, sdk_exceptions_1.createMalformedTokenError)();
        }
        try {
            // Recover the token signer
            tokenSigner = (0, ec_recover_1.ecRecover)(claim, proof).toLowerCase();
            // Recover the attachment signer
            if (attachment && attachment !== 'none') {
                attachmentSigner = (0, ec_recover_1.ecRecover)(attachment, parsedClaim.add).toLowerCase();
            }
        }
        catch (_b) {
            throw (0, sdk_exceptions_1.createFailedRecoveringProofError)();
        }
        // Assert the expected signer
        if (claimedIssuer !== tokenSigner || (attachmentSigner && claimedIssuer !== attachmentSigner)) {
            throw (0, sdk_exceptions_1.createIncorrectSignerAddressError)();
        }
        const timeSecs = Math.floor(Date.now() / 1000);
        const nbfLeeway = 300; // 5 min grace period
        // Assert the token is not expired
        if (parsedClaim.ext < timeSecs) {
            throw (0, sdk_exceptions_1.createTokenExpiredError)();
        }
        // Assert the token is not used before allowed.
        if (parsedClaim.nbf - nbfLeeway > timeSecs) {
            throw (0, sdk_exceptions_1.createTokenCannotBeUsedYetError)();
        }
        // Assert the audience matches the client ID.
        if (this.sdk.clientId && parsedClaim.aud !== this.sdk.clientId) {
            throw (0, sdk_exceptions_1.createAudienceMismatchError)();
        }
    }
    decode(DIDToken) {
        const parsedToken = (0, parse_didt_1.parseDIDToken)(DIDToken);
        return parsedToken.withParsedClaim;
    }
    getPublicAddress(DIDToken) {
        const claim = this.decode(DIDToken)[1];
        const claimedIssuer = claim.iss.split(':')[2];
        return claimedIssuer;
    }
    getIssuer(DIDToken) {
        return this.decode(DIDToken)[1].iss;
    }
}
exports.TokenModule = TokenModule;
//# sourceMappingURL=index.js.map